<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="北航OS实验总结，关于具体实现可能说得会少一些，主要是对整体思路流程和难点的梳理。 各种常量、函数和宏定义  BY2PG：一页的字节数，等于4096 PPN(x)&#x2F;VPN(x)：查询在第几页，即除以一页的大小 npage：物理页数 memsize：总物理内存的字节数 alloc(n, align, clear)：分配n字节的空间，并且以align字节对齐，clear表示是否清零 函数中的exter">
<meta property="og:type" content="article">
<meta property="og:title" content="OS实验汇总">
<meta property="og:url" content="https://hany01rye.github.io/p/OS-Lab/index.html">
<meta property="og:site_name" content="Hany01&#39;s Blog">
<meta property="og:description" content="北航OS实验总结，关于具体实现可能说得会少一些，主要是对整体思路流程和难点的梳理。 各种常量、函数和宏定义  BY2PG：一页的字节数，等于4096 PPN(x)&#x2F;VPN(x)：查询在第几页，即除以一页的大小 npage：物理页数 memsize：总物理内存的字节数 alloc(n, align, clear)：分配n字节的空间，并且以align字节对齐，clear表示是否清零 函数中的exter">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/Hany01/1830836/o_231203014535_1.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/Hany01/1830836/o_231203014703_1.jpg">
<meta property="article:published_time" content="2023-04-04T12:36:50.000Z">
<meta property="article:modified_time" content="2023-12-03T01:56:08.073Z">
<meta property="article:author" content="Rye Han">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.cnblogs.com/cnblogs_com/Hany01/1830836/o_231203014535_1.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>OS实验汇总</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/hany01rye">Projects</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/p/loj6569-cactuses-counting/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hany01rye.github.io/p/OS-Lab/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hany01rye.github.io/p/OS-Lab/&text=OS实验汇总"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hany01rye.github.io/p/OS-Lab/&is_video=false&description=OS实验汇总"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=OS实验汇总&body=Check out this article: https://hany01rye.github.io/p/OS-Lab/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hany01rye.github.io/p/OS-Lab/&name=OS实验汇总&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B8%B8%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">各种常量、函数和宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Lab2 - 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="toc-number">2.1.</span> <span class="toc-text">内核程序启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">页管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">Page的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%8A%E4%B8%80%E8%8A%82%E7%9A%84page-init"><span class="toc-number">2.2.3.</span> <span class="toc-text">回顾上一节的page_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EPage%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">关于Page管理的其它函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">2.3.</span> <span class="toc-text">页表相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%86%E4%B8%8E%E8%BD%AC%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">不同地址的区分与转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kseg0%E6%AE%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">kseg0段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kuseg%E6%AE%B5%EF%BC%88%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">kuseg段（两级页表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">2.5.</span> <span class="toc-text">TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E8%A1%A8%E9%A1%B9%E6%97%A0%E6%95%88%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">旧表项无效化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLB%E9%87%8D%E5%A1%AB"><span class="toc-number">2.5.2.</span> <span class="toc-text">TLB重填</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">Lab3 - 进程与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97Env"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程控制块Env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86ASID"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程标识ASID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEEnv"><span class="toc-number">3.1.3.</span> <span class="toc-text">设置Env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B9%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text">加载文件并创建进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.5.</span> <span class="toc-text">进程的运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.</span> <span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E5%8F%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">异常分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">3.2.2.</span> <span class="toc-text">时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%88%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">进程调度（时间片轮转）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E-fork"><span class="toc-number">4.</span> <span class="toc-text">Lab4 - 系统调用与 fork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">4.2.</span> <span class="toc-text">fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6COW"><span class="toc-number">4.2.1.</span> <span class="toc-text">写时复制COW</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">Lab5 - 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">磁盘空间布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">文件系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.</span> <span class="toc-text">块缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.</span> <span class="toc-text">文件系统的用户接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">Lab6 - 管道和命令解释程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E6%80%A7%E5%AE%9E%E9%AA%8C%EF%BC%88Lab4%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">挑战性实验（Lab4）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E6%80%9D%E8%B7%AF"><span class="toc-number">7.1.</span> <span class="toc-text">大致思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.1.</span> <span class="toc-text">如何传递信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.2.</span> <span class="toc-text">何时处理信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.3.</span> <span class="toc-text">如何处理信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">7.1.4.</span> <span class="toc-text">其它需要注意的事情</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82"><span class="toc-number">7.2.</span> <span class="toc-text">具体实现及相关细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">信号集相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97Env%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">7.2.2.</span> <span class="toc-text">进程控制块Env需要增加的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="toc-number">7.2.3.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.3.</span> <span class="toc-text">问题及解决方案</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        OS实验汇总
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">Hany01's Blog</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-04-04T12:36:50.000Z" itemprop="datePublished">2023-04-04</time>
    </div>


      
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/OS/" rel="tag">OS</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>北航OS实验总结，关于具体实现可能说得会少一些，主要是对整体思路流程和难点的梳理。</p>
<h2 id="各种常量、函数和宏定义"><a href="#各种常量、函数和宏定义" class="headerlink" title="各种常量、函数和宏定义"></a>各种常量、函数和宏定义</h2><blockquote>
<ul>
<li><code>BY2PG</code>：一页的字节数，等于4096</li>
<li><code>PPN(x)</code>/<code>VPN(x)</code>：查询在第几页，即除以一页的大小</li>
<li><code>npage</code>：物理页数</li>
<li><code>memsize</code>：总物理内存的字节数</li>
<li><code>alloc(n, align, clear)</code>：分配<code>n</code>字节的空间，并且以<code>align</code>字节对齐，<code>clear</code>表示是否清零<ul>
<li>函数中的<code>extern char end[];</code>是Lab1中<code>kernel.lds</code>中的<code>end</code>，对应虚拟地址<code>0x80400000</code>，对应的物理地址为<code>0x00400000</code>。我们管理的物理内存也就是<code>0x00400000</code>~<code>memsize-1</code></li>
</ul>
</li>
<li><code>freemem</code>：物理内存分配到哪个地方了</li>
<li><code>ULIM</code>：<code>0x80000000</code></li>
<li><code>PADDR(kva)</code>：将内核的虚拟地址（<code>kseg0</code>）转化为物理地址，即减<code>ULIM</code></li>
<li><code>KADDR(pa)</code>：将物理地址转化为内核的虚拟地址，即加<code>ULIM</code></li>
<li><code>pages[0]</code>…<code>pages[npages-1]</code>：<code>Page</code>类型的页控制块（单个大小为12B）</li>
<li><code>page2ppn(struct Page *pp)</code>：从<code>Page</code>指针到物理页数的转换，即这个指针是第几个<code>pages</code></li>
<li><code>page2pa(struct Page *pp)</code>：从<code>Page</code>指针到物理地址的转换；实现方式为先用<code>page2ppn</code>得到这是第几个控制块/物理页，再将页数左移12位</li>
<li><code>page2kva(struct Page *pp)</code>：从<code>Page</code>指针到内核虚拟地址的转换；实现方式为<code>KADDR(page2pa(pp))</code></li>
<li><code>pa2page(u_long pa)</code>：查询地址<code>pa</code>所在页的<code>pages</code>指针</li>
<li><code>ROUND(freemem, width)</code>：对齐</li>
<li><code>PDX(va)</code>：获取一级页表项偏移</li>
<li><code>DTX(va)</code>：获取二级页表项偏移</li>
<li><code>PTE_ADDR(va)</code>：获取表项中的地址，即 将表项中的权限位 置零</li>
<li><code>PTE_V</code>：有效位</li>
<li><code>PTE_D</code>：可写位</li>
<li><code>panic_on(expr)</code>：如果<code>expr</code>不等于0，则报错</li>
<li><code>Elf32_Ehdr</code>：ELF头信息</li>
<li><code>Elf32_Phdr</code>：段头表</li>
<li><code>ELF_FOREACH_PHDR_OFF(ph_off, ehdr)</code>：循环枚举段头表的每一项，<code>ehdr</code>是ELF头信息，<code>ph_off</code>存当前偏移位置，<code>_ph_idx</code>存当前是第几项；<code>ph_off</code>需要自己额外定义，类型为<code>size_t</code></li>
<li><code>STATUS_xxx</code>：SR寄存器的每一位，可以参考预习教程中的图</li>
</ul>
</blockquote>
<h2 id="Lab2-内存管理"><a href="#Lab2-内存管理" class="headerlink" title="Lab2 - 内存管理"></a>Lab2 - 内存管理</h2><h3 id="内核程序启动"><a href="#内核程序启动" class="headerlink" title="内核程序启动"></a>内核程序启动</h3><ul>
<li><p><code>mips_detect_memory()</code>：已经得到了物理内存的字节数<code>memsize</code>，除以物理页大小<code>BY2PG</code>得到页数<code>npage</code></p>
</li>
<li><p><code>mips_vm_init()</code>：通过<code>alloc()</code>分配<code>npage</code>个结构体<code>Page</code>的空间（注意这里分配的是管理结构的空间，不是页的空间）</p>
<p><code>alloc(n, align, clear)</code>表示分配<code>n</code>字节、以<code>align</code>对齐、是否清零，它是<strong>基于<code>kseg0</code>段</strong>、用<code>memset</code>直接操作的</p>
<p><code>freemem</code>存的是当前<strong>虚拟</strong>地址分配到什么位置了，最开始从<code>end</code>即虚拟内存<code>0x80400000</code>、物理内存<code>0x400000</code>开始分配</p>
</li>
<li><p><code>page_init()</code>：初始化<code>pages</code>数组和空闲链表</p>
</li>
</ul>
<h3 id="页管理"><a href="#页管理" class="headerlink" title="页管理"></a>页管理</h3><h4 id="Page的结构"><a href="#Page的结构" class="headerlink" title="Page的结构"></a><code>Page</code>的结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Page &#123;</span><br><span class="line">	Page_LIST_entry_t &#123;</span><br><span class="line">		Page *le_next;</span><br><span class="line">		Page **le_prev;</span><br><span class="line">	&#125; pp_link;</span><br><span class="line">	u_short pp_ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Page_list</code>结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Page_list &#123;</span><br><span class="line">    Page* lh_first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong><code>le_next</code>指向的是下一个<code>Page</code>，而<code>le_prev</code>指向的是上一个<code>Page</code>的<code>le_next</code></strong>。</p>
<p><code>pp_ref</code>表示被引用了几次（也就是有多少个虚拟页映射到了这个物理页），如果引用次数为0就说明没有被占用。</p>
<p><code>Page_list</code>仅包含一个<code>Page</code>指针，指向链表头。</p>
<p>关于链表的各种操作的实现此处不再赘述，关于Exercise 2.2需要补写的<code>LIST_INSERT_AFTER</code>也并不难。</p>
<h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><p><code>page_free_list</code>是空闲链表，存的是所有空闲的页控制块。</p>
<ul>
<li>需要分配内存时，将空闲链表头部的页控制块从链表取出并分配</li>
<li>当某页的引用次数为0时，将页控制块插入空闲链表头部</li>
</ul>
<h4 id="回顾上一节的page-init"><a href="#回顾上一节的page-init" class="headerlink" title="回顾上一节的page_init"></a>回顾上一节的<code>page_init</code></h4><p>主要干了这么几件事：</p>
<ul>
<li><p>初始化<code>page_free_list</code></p>
</li>
<li><p>以按页面大小对齐后的<code>freemem</code>为界限</p>
<p>前面是已经被内核和管理结构使用的物理页，需要指定它们的<code>pp_ref</code>为1</p>
<p>后面是还未被使用的物理页，它们的<code>pp_ref</code>是0，并且需要被插入<code>page_free_list</code></p>
</li>
</ul>
<h4 id="关于Page管理的其它函数"><a href="#关于Page管理的其它函数" class="headerlink" title="关于Page管理的其它函数"></a>关于<code>Page</code>管理的其它函数</h4><p><code>int page_alloc(Page **new)</code>：从空闲链表头部取出元素并分配（如果链表为空则报错），用<code>page2kva</code>获得该页管理的虚拟地址并清零。需要注意的是，这里并不需要修改<code>pp_ref</code>。</p>
<p><code>void page_free(Page *pp)</code>：将<code>pp</code>插入空闲链表</p>
<p><code>void page_decref(Page *pp)</code>：将<code>pp_ref</code>减一，如果减到0，就调用<code>page_free</code></p>
<h3 id="页表相关"><a href="#页表相关" class="headerlink" title="页表相关"></a>页表相关</h3><p>页目录项类型名为<code>Pde</code>，页表项类型名为<code>Pte</code>，其本质都是<code>u_long</code></p>
<p>函数中页目录的基地址一般叫<code>pgdir</code>，类型为<code>Pde*</code>，将<code>pgdir</code>加上<code>PDX(va)</code>即可得到所在的页目录项。在实现二级页表检索的函数<code>pgdir_walk</code>中，我们需要判断该目录项是否有效，根据要求判断是否需要调用<code>page_alloc</code>进行分配。接着通过页目录项<code>pgdir_entryp</code>找到对应页表<code>(Pte*)KADDR(PTE_ADDR(*pgdir_entryp))</code>（通过<code>KADDR</code>将物理地址转换成<code>kseg0</code>段的虚拟地址以便访问）</p>
<p><code>page_lookup</code>：找到虚拟地址<code>va</code>的所在页，返回<code>Page*</code>，并将页表项存入<code>*ppte</code>；若<code>va</code>没有映射到任何页，则返回<code>NULL</code></p>
<p><code>page_remove</code>：取消虚拟地址<code>va</code>对物理页的映射，调用<code>page_decref</code>，最后更新TLB表项（TLB相关内容将会在后文进行说明）</p>
<p><code>page_insert</code>：将虚拟地址<code>va</code>映射到<code>pp</code>控制的物理页，并将权限设置为<code>perm</code>（判断以前已经存在映射，如果以前的映射不一样，那么<code>page_remove</code>后正常执行；否则调用<code>tlb_invalidate</code>并修改权限位后直接返回）</p>
<h3 id="不同地址的区分与转化"><a href="#不同地址的区分与转化" class="headerlink" title="不同地址的区分与转化"></a>不同地址的区分与转化</h3><h4 id="kseg0段"><a href="#kseg0段" class="headerlink" title="kseg0段"></a><code>kseg0</code>段</h4><p><code>Page</code>-&gt;物理页号：看数组下标（指针相减）即可；物理页号-&gt;<code>Page</code>：取对应下标的数组；</p>
<p>物理页号-&gt;物理地址：将页数左移12位；物理地址-&gt;物理页号：将页数右移12位；</p>
<p>物理地址-&gt;虚拟地址：<code>+ULIM</code>；虚拟地址-&gt;物理地址：<code>-ULM</code>；</p>
<p>我们实验中的物理内存大小为64MB，即<code>0x00000000</code>~<code>0x03999999</code>，对应的<code>kseg0</code>段上的虚拟地址是<code>0x80000000</code>~<code>0x83999999</code>（从<code>0x84000000</code>开始为“Invalide Memory”）</p>
<p>我们在<strong>内核态</strong>对物理内存进行修改时，都是通过<code>kseg0</code>段处理的。</p>
<h4 id="kuseg段（两级页表）"><a href="#kuseg段（两级页表）" class="headerlink" title="kuseg段（两级页表）"></a><code>kuseg</code>段（两级页表）</h4><ul>
<li><p>虚拟地址：</p>
<ul>
<li>31-22位为一级页表项偏移量，通过<code>PDX(va)</code>获取</li>
<li>21-12位为二级页表项偏移量，通过<code>PTX(va)</code>获取</li>
<li>11-0位为页内偏移量</li>
</ul>
</li>
<li><p>页表项：</p>
<ul>
<li>31-12位为物理页号</li>
<li>11-0位为标志位，定义规范与<code>EntryLo</code>相同，除了有效位<code>PTE_V</code>和可写位<code>PTE_D</code>，其它位在本次Lab中不会涉及</li>
</ul>
<p>一个页表项为32位即4B，一页是4KB，故一级页目录中有1024个页表项，对应着1024个页表，每个页表占一页即4KB，故这些页表映射了4MB空间，对应用户空间的<code>0x7fc00000</code>~<code>0x7fffffff</code>。（<code>0x7fc00000</code>即<code>mmu.h</code>的地图中<code>UVPT</code>的位置；另外，图中<code>PDMAP</code>等于$4\times 1024\times 1024$，表示⼀个⼀级页表所映射的1024个⼆级⻚表的⼤⼩）</p>
<p>在这个范围内，有1024个页表，对应着整个<code>0x00000000</code>~<code>0xffffffff</code>，而其中有一个页表映射的空间刚好是从<code>0x7fc00000</code>开始的，这个页表的编号是<code>0x7fc00000&gt;&gt;12</code>，而这个页表实际上就是页目录，对应着<code>0x7fc00000</code>~<code>0x7fffffff</code>范围内的所有页表项，这也就是页目录的自映射。</p>
</li>
</ul>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p>CP0寄存器中的<code>EntryHi</code>和<code>EntryLo</code>分别对应着TLB的Key和Data：</p>
<ul>
<li><code>EntryHi</code>即TLB的Key：由VPN（Virtual Page Number）（20位，由页目录偏移和页表偏移组成）和ASID（Address Space IDentifier）（用于区分不同的地址空间）组成</li>
<li><code>EntryLo</code>即TLB的Data：由PFN（Physical Frame Number）（20位，物理页框号）和各种有效位组成，<strong>和页表项的格式一致</strong></li>
</ul>
<h4 id="旧表项无效化"><a href="#旧表项无效化" class="headerlink" title="旧表项无效化"></a>旧表项无效化</h4><p><code>tlb_invalidate</code>：更新页表项时，需要调用它进行旧表项无效化；具体来说就是将旧表项的Key写入<code>EntryHi</code>并通过<code>tlbp</code>指令查找对应旧表项，若存在，则将其清零（在<code>EntryHi</code>和<code>EntryLo</code>中写0并调用<code>tlbwi</code>）</p>
<h4 id="TLB重填"><a href="#TLB重填" class="headerlink" title="TLB重填"></a>TLB重填</h4><p><code>do_tlb_refill</code>：从<code>BadVAddr</code>中取出引发 TLB 缺失的虚拟地址，从<code>EntryHi</code>的 6~11 位取出当前进程的 ASID，根据虚拟地址和 ASID 查找页表，得到包含物理地址的页表项；将物理地址存入 <code>EntryLo</code>, 并执行<code>tlbwr</code>将此时的<code>EntryHi</code>与<code>EntryLo</code>写入到 TLB 中。</p>
<h2 id="Lab3-进程与异常"><a href="#Lab3-进程与异常" class="headerlink" title="Lab3 - 进程与异常"></a>Lab3 - 进程与异常</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="进程控制块Env"><a href="#进程控制块Env" class="headerlink" title="进程控制块Env"></a>进程控制块Env</h4><p><code>struct Env</code>用于实现进程控制块PCB，各成员变量在指导书中已详细介绍、此处不再赘述；值得注意的是，结构体中有两个用于队列链接的成员，<code>env_link</code>控制空闲进程链表<code>env_free_list</code>，<code>env_sched_link</code>控制调度队列<code>env_sched_list</code>，其中<code>env_sched_list</code>是另外一种链表实现方式：<code>TAILQ</code>，即双端队列，可以在<code>queue.h</code>中查看对应的宏的使用方式。</p>
<p>Exercise 3.1即初始化两个队列：调度队列直接<code>INIT</code>即可；空闲队列在<code>INIT</code>之后还需要插入<code>envs</code>数组中的元素，由于题目要求编号更小的进程控制块被优先分配，所以需要将这<code>NENV</code>个元素倒序插入。</p>
<p>在<code>env_init</code>函数中除了Exercise 3.1的对两个队列进行初始化，还用<code>page_alloc</code>申请了一页物理内存作为页目录，并求出页目录基地址对应的内核虚拟地址<code>base_pgdir</code>，接着将内核中的页控制块<code>pages</code>数组和进程控制块<code>envs</code>数组映射到用户空间的 <code>UPAGES</code> 和 <code>UENVS</code> 处（可以在<code>mmu.h</code>的图中回顾<code>UPAGES</code>和<code>UENVS</code>的位置分布）。上述“映射”过程用<code>map_segment</code>函数实现，即Exercise 3.2的实验内容，将每页的内容分别用<code>page_insert</code>添加映射即可。这一部分内容是每一个进程共享的只读空间，之后在创建进程的时候，我们会将它们拷贝到每个进程的页目录中，让每一个用户进程都可以读取这部分内容。</p>
<h4 id="进程标识ASID"><a href="#进程标识ASID" class="headerlink" title="进程标识ASID"></a>进程标识ASID</h4><p>在Lab2中提过，ASID，Address Space IDentifier，⽤于区分不同的地址空间，同⼀虚拟地址在不同的地址空间中通常映射到不同的物理地址。</p>
<p>ASID对进程具有唯一标识性，有6个bit，即只有64个可用的ASID，在本实验中用位图法管理，即<code>asid_bitmap</code>数组。</p>
<h4 id="设置Env"><a href="#设置Env" class="headerlink" title="设置Env"></a>设置Env</h4><p>流程：</p>
<ol>
<li><p>从<code>env_free_list</code>中取出一个空闲控制块</p>
</li>
<li><p>填写进程信息，其中<code>env_id</code>用<code>mkenvid</code>分配，<code>env_asid</code>用<code>asid_alloc</code>分配</p>
</li>
<li><p><strong>初始化页目录（<code>env_setup_vm</code>）</strong></p>
<p>用<code>page_alloc</code>申请一个物理页，作为页目录，并得到基地址对应的内核虚拟地址<code>env_pgdir</code>，然后将我们初始化时以<code>base_pgdir</code>为基地址的页目录中的<code>UPAGES</code>段和<code>UENVS</code>段（即地图中<code>UTOP</code>到<code>UVPT</code>这一段）拷贝到当前进程。</p>
</li>
<li><p>从链表中摘出</p>
</li>
</ol>
<h4 id="加载文件并创建进程"><a href="#加载文件并创建进程" class="headerlink" title="加载文件并创建进程"></a>加载文件并创建进程</h4><p>（我们目前没有实现文件系统，所以实验中暂时用的是数组）</p>
<blockquote>
<p>下面是相关的各个文件及函数：</p>
<ul>
<li><code>kern/env.c</code><ul>
<li><code>static int load_icode_mapper(void *data, u_long va, size_t offset, u_int perm, const void *src, size_t len)</code>：申请一个新的物理页，将<code>src</code>填在<code>offset</code>处，并将进程<code>env=(struct Env*)data</code>下的虚拟地址<code>va</code>映射到此页</li>
<li><code>static void load_icode(struct Env *e, const void *binary, size_t size)</code>：先用<code>elf_from</code>将<code>binary</code>强转并存入<code>ehdr</code>，枚举段头表的每一项，调用<code>elf_load_seg</code>分别分配文件需要的空间和内存需要的空间。分配时有两段，一段是长度为<code>bin_size</code>的<code>.text</code>和<code>.data</code>，另一段是长度为<code>sg_size-bin_size</code>的<code>.bss</code>，加载地址布局可参考P85图3.2；最后，<code>env_tf.cp0_epc</code>表示恢复运行时<code>PC</code>的位置，这里指到程序入口<code>e_entry</code></li>
<li><code>struct Env *env_create(const void *binary, size_t size, int priority)</code>：先<code>env_alloc</code>，设置一些信息，然后调用<code>load_icode</code>并插入调度队列<code>env_sched_list</code></li>
</ul>
</li>
<li><code>include/elf.h</code><ul>
<li><code>struct Elf32_Ehdr</code></li>
<li><code>struct Elf32_Phdr</code></li>
<li><code>ELF_FOREACH_PHDR_OFF(ph_off, ehdr)</code>：循环枚举段头表的每一项，<code>ehdr</code>是ELF头信息，<code>ph_off</code>存当前偏移位置，<code>_ph_idx</code>存当前是第几项</li>
</ul>
</li>
<li><code>lib/elfloader.c</code><ul>
<li><code>const Elf32_Ehdr *elf_from(const void *binary, size_t size)</code>：将<code>binary</code>强转为<code>Elf32_Ehdr*</code>类型，并判断<code>size</code>和魔数，如果合法则返回<code>Elf32_Ehdr</code>结构体，否则返回<code>NULL</code></li>
<li><code>int elf_load_seg(Elf32_Phdr *ph, const void *bin, elf_mapper_t map_page, void *data)</code></li>
</ul>
</li>
</ul>
<p><strong>调用结构</strong>：<code>env_create</code>调用<code>load_icode</code>，<code>load_icode</code>将<code>load_icode_mapper</code>作为参数调用<code>elf_load_seg</code></p>
</blockquote>
<h4 id="进程的运行"><a href="#进程的运行" class="headerlink" title="进程的运行"></a>进程的运行</h4><p><code>env_run</code>：运行新进程前需要保存旧进程的上下文（进程执行时所有寄存器的状态，也就是<code>Trapframe</code>），即<code>curenv-&gt;env_tf=*((struct Trapframe *)KSTACKTOP - 1)</code>；然后调用<code>env_pop_tf</code>恢复新进程的上下文。</p>
<h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><p>流程：异常产生-&gt;异常分发-&gt;时钟中断</p>
<h4 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h4><p>在<code>kern/entry.S</code>中，<code>exc_gen_entry</code>用于异常分发，作用是保存上下文、取出<code>Cause</code>寄存器的2-6位、在<code>exception_handlers</code>数组（异常向量组，位于<code>kern/traps.c</code>）中找到对应的异常处理函数并调用。</p>
<h4 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h4><blockquote>
<p>区分<strong>中断</strong>和<strong>异常</strong>：</p>
<ul>
<li>异常：包括0号中断异常，1号存储异常等</li>
<li>中断：（在本次实验中我们认为）属于异常的一种，包括4号时钟中断（<code>IM4</code>）等</li>
</ul>
</blockquote>
<p>Exercise 3.11需要在<code>kern/kclock.S</code>的<code>kclock_init</code>函数中设置时间片轮转的频率为200。</p>
<h4 id="进程调度（时间片轮转）"><a href="#进程调度（时间片轮转）" class="headerlink" title="进程调度（时间片轮转）"></a>进程调度（时间片轮转）</h4><p>对于调度链表，每次存储上下文后取出头部进程来调度。</p>
<h2 id="Lab4-系统调用与-fork"><a href="#Lab4-系统调用与-fork" class="headerlink" title="Lab4 - 系统调用与 fork"></a>Lab4 - 系统调用与 fork</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>允许内核执行用户程序的代码不安全，因此需要一系列内核空间中的函数，当用户进程需要进行这些操作时，会引发特定的异常以陷入内核态，由内核调用对应的函数，从而安全地为用户进程提供受限的系统级操作。</p>
<p>补充：用户态和内核态由CP0<code>SR</code>寄存器中<code>KUc</code>位的值标志</p>
<p>关于<code>syscall</code>的实现，参考图4.1，Thinking4.1的第三问是关于参数的传递，需要对MIPS中函数调用中参数的传递进行理解，关于栈帧的更详细的内容在OSome网站的预习教程中有：<a target="_blank" rel="noopener" href="http://os.buaa.edu.cn/tutorial。">http://os.buaa.edu.cn/tutorial。</a></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>fork流程：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/Hany01/1830836/o_231203014535_1.png" style="zoom:80%;" /></p>
<p>在运行过程中，如果遇到tlb mod异常，则会根据<code>cow_entry()</code>进行处理</p>
<h4 id="写时复制COW"><a href="#写时复制COW" class="headerlink" title="写时复制COW"></a>写时复制COW</h4><p>简单来说，就是不在一开始全部复制，而是将需要复制的页面的<code>PTE_V</code>标成0，<code>PTE_COW</code>标成1，到时候要写的时候由于<code>PTE_V</code>为0、触发异常，再分配新物理页。</p>
<h2 id="Lab5-文件系统"><a href="#Lab5-文件系统" class="headerlink" title="Lab5 - 文件系统"></a>Lab5 - 文件系统</h2><h3 id="磁盘空间布局"><a href="#磁盘空间布局" class="headerlink" title="磁盘空间布局"></a>磁盘空间布局</h3><p>磁盘被分成若干个磁盘块（磁盘块是虚拟概念），在本实验中每个磁盘块大小为4096Byte；盘中有<code>NBLOCK=1024</code>个块。</p>
<p>第一个磁盘块当作引导扇区和分区表。</p>
<p>第二个磁盘块为超级块Super Block，用来描述文件系统的基本信息，包括：</p>
<ul>
<li><code>s_magic</code>：魔数，常量，用于标识文件系统</li>
<li><code>s_nblocks</code>：磁盘块数量，本实验中为1024</li>
<li><code>s_root</code>：根目录，类型为<code>File</code>，<code>File</code>具体内容在下一小节，其中<code>f_type</code>为<code>FTYPE_DIR</code>，<code>fname</code>为<code>&quot;/&quot;</code></li>
</ul>
<p>之后的一些块用位图管理磁盘资源，值得注意的是，1表示空闲，0表示占用；最后剩下的块就是用来存目录和文件的。</p>
<p>具体实现中（<code>tools/fsformat.c</code>的<code>init_disk()</code>），第0、1个块已经被占用，我们就从第2个块开始分配，需要 $\texttt{nbitblock}=\lceil \frac{\texttt{NBLOCK}}{\texttt{BIT2BLK}}\rceil$ 个块来作为位图（即 <code>BLOCK_BMAP</code> 类型），真正的数据从 $\texttt{nbitblock+2}$ 即 <code>nextbno</code> 的初值开始。我们指定这些作为位图的块的类型并将所有位都赋为 1，如果位图最后有一些由于不能整除而产生的无意义的边角料，我们把边角料对应的位赋为 0。最后对超级块赋值。</p>
<h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>（<code>struct File</code>的定义在<code>user/include/fs.h</code>）</p>
<p>需要注意的是 <code>f_direct[NDIRECT]</code> 表示各个数据块在磁盘上的位置，每个块是 4KB，最多10个块即40KB。</p>
<p>若超过40KB，则用 <code>f_indirect</code> 指向间接磁盘块：磁盘块大小仍是4KB，每一项32位即4B，为了方便我们前10个项留空，也就是共4KB/4B=1024个项，每项对应一个4KB大的磁盘块，即单个文件大小最大是4MB。</p>
<p><code>f_dir</code> 表示父目录；<code>f_pad</code>用于使控制块占满 256B。</p>
<h3 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h3><p>文件系统服务也是一个进程，同样拥有 4GB 虚拟内存；我们将 <code>DISKMAP</code> 到 <code>DISKMAP+DISKMAX</code> 这一段作为缓冲区，映射磁盘空间。</p>
<p><code>DISKMAX</code> 大小为 1GB，可以容纳 256 个大小为 4MB 的磁盘块。</p>
<h3 id="文件系统的用户接口"><a href="#文件系统的用户接口" class="headerlink" title="文件系统的用户接口"></a>文件系统的用户接口</h3><p>这一部分涉及的文件和函数特别多，这里用偷来的一张图总结：</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/Hany01/1830836/o_231203014703_1.jpg" alt=""></p>
<h2 id="Lab6-管道和命令解释程序"><a href="#Lab6-管道和命令解释程序" class="headerlink" title="Lab6 - 管道和命令解释程序"></a>Lab6 - 管道和命令解释程序</h2><p>最后一次实验没有上机，我**直接抄抄抄抄抄抄</p>
<h2 id="挑战性实验（Lab4）"><a href="#挑战性实验（Lab4）" class="headerlink" title="挑战性实验（Lab4）"></a>挑战性实验（Lab4）</h2><h3 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h3><h4 id="如何传递信号"><a href="#如何传递信号" class="headerlink" title="如何传递信号"></a>如何传递信号</h4><p>对于每个进程，我们维护一个待处理信号队列；</p>
<p>对于<code>kill</code>函数，我们只需通过系统调用、将这个信号丢到目标进程的待处理信号队列中即可。</p>
<h4 id="何时处理信号"><a href="#何时处理信号" class="headerlink" title="何时处理信号"></a>何时处理信号</h4><p>每次从内核态返回用户态都需要恢复现场，在<code>ret_from_exception</code>的前面对于待处理信号进行检查是一个不错的选择。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">	move    a0, sp</span><br><span class="line">	addiu   sp, sp, -8</span><br><span class="line">	jal     do_signal</span><br><span class="line">	nop</span><br><span class="line">	addiu   sp, sp, 8</span><br><span class="line">	RESTORE_SOME</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="如何处理信号"><a href="#如何处理信号" class="headerlink" title="如何处理信号"></a>如何处理信号</h4><p>仿照<code>do_tlb_mod</code>的方式写出<code>do_signal</code>，如果选出一个可以被屏蔽的信号，就将信号码和处理函数传到入口函数，然后我们对于信号进行判断，根据需要调用信号处理函数。值得注意的是，我们在处理信号期间使用的掩码应该是信号的掩码而不是进程的掩码，我们需要对当前掩码进行备份、将进程掩码修改为信号掩码，等处理完毕，再用备份掩码修改回来。其中入口函数的写法可以模仿<code>cow_entry</code>。</p>
<h4 id="其它需要注意的事情"><a href="#其它需要注意的事情" class="headerlink" title="其它需要注意的事情"></a>其它需要注意的事情</h4><ul>
<li>题目要求子进程继承父进程的<code>sigaction</code>，核心态比较方便进行操作，于是我们可以直接在<code>sys_exofork()</code>中将需要继承的信息传下去</li>
<li>对于<code>SIGSEGV</code>，我们只需要在<code>passive_alloc</code>中的<code>if</code>判断中加上<code>sys_kill(0, SIGSEGV)</code>即可</li>
</ul>
<h3 id="具体实现及相关细节"><a href="#具体实现及相关细节" class="headerlink" title="具体实现及相关细节"></a>具体实现及相关细节</h3><h4 id="信号集相关操作"><a href="#信号集相关操作" class="headerlink" title="信号集相关操作"></a>信号集相关操作</h4><p>这里是比较简单的部分，只涉及简单的位运算，故不做赘述。</p>
<h4 id="进程控制块Env需要增加的内容"><a href="#进程控制块Env需要增加的内容" class="headerlink" title="进程控制块Env需要增加的内容"></a>进程控制块Env需要增加的内容</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    u_int env_sig_handler_entry; <span class="comment">//信号处理入口</span></span><br><span class="line">	<span class="type">sigset_t</span> env_signal_blocked; <span class="comment">//进程掩码</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env_pending_sig</span> <span class="title">env_pending_sig</span>;</span> <span class="comment">//待处理信号序列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">env_sig_handler</span>[64];</span> <span class="comment">//不同信号的掩码及处理函数</span></span><br><span class="line">	u_int latest_time; <span class="comment">//当前处理栈内最晚的时间戳</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各成员的作用已在注释中标明。</p>
<p>对于其中的待处理信号序列，我用的是现成的<code>TAILQ</code>的队列操作，跟进程控制块的<code>env_list</code>和<code>env_sched_list</code>类似，我们可以创建一个<code>env_free_sig</code>，并对每一个进程创建一个<code>env_pending_sig</code>分别表示空闲的信号控制块和该进程待处理的信号控制块。</p>
<h4 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h4><ul>
<li><code>syscall_sigaction()</code>：<code>sigaction()</code>的系统调用，用于修改当前进程对应信号的<code>struct sigaction</code></li>
<li><code>syscall_sigprocmask()</code>：<code>sigprocmask()</code>的系统调用，用于对进程掩码进行各种修改</li>
<li><code>syscall_get_env_mask()</code>：获取进程掩码</li>
<li><code>syscall_get_sig_mask()</code>：获取信号掩码</li>
<li><code>syscall_kill()</code>：传信号，即将信号码丢进对应进程的待处理信号队列</li>
<li><code>syscall_set_sig_entry()</code>：在最开始（<code>libos.c</code>中）进行调用，设置初始进程的入口函数（在<code>sys_exofork()</code>中会将入口函数下传）</li>
<li><code>syscall_set_time_stamp()</code>：更新对应进程的信号处理栈的最新时间戳</li>
</ul>
<h3 id="问题及解决方案"><a href="#问题及解决方案" class="headerlink" title="问题及解决方案"></a>问题及解决方案</h3><p>我们是在<code>ret_from_exception</code>处进行的检查，这意味着每次系统调用都会进行检查、发现可处理的信号就进行处理。（举个例子，我们在处理某个信号时时间片结束，当我们再次切换到这个进程时，经过<code>ret_from_exception</code>时则会暂时不管当前信号处理过程而对于另一个信号进行处理）</p>
<p>此外，（在多次询问助教后）我得知关于更详细的信号处理的顺序应该是这样的：信号是可重入的，我们可能会在处理A信号时收到B信号、开始处理B信号后又收到C信号，然后开始处理C信号……一方面，我们只需要考虑当前信号的掩码，也就是在处理C信号时无需考虑A、B信号和进程本身的掩码；另一方面，在A、B信号处理过程中收到并被阻塞的信号即使在C中不在屏蔽集中，仍然需要被屏蔽。一个进程只有一个待处理队列，我们需要想办法区分和处理之前已经被屏蔽的信号和当前不被屏蔽的信号。</p>
<p>我的解决方法是，对于信号记录一个时间戳。每有一个新的信号，我们就记录一次时间戳（全局变量），我们把一个进程的可重入信号看作是栈，那么这个栈需要内部元素的时间戳是单调递增的。也就是说我们在判断掩码等条件时，同样需要判断当前信号的时间戳是否大于栈顶元素的时间戳，满足条件才能处理该信号。</p>
<p>由于获取和修改时间戳本身是需要陷入内核的，因此我们需要实现得较为精细。我们可以通过一次系统调用同时修改时间戳并进行备份，具体系统调用函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_set_time_stamp</span><span class="params">(u_int envid, <span class="type">int</span> *stamp)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	envid2env(envid, &amp;e, <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t = e -&gt; latest_time;</span><br><span class="line">	e -&gt; latest_time = *stamp;</span><br><span class="line">	*stamp = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体处理过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sigset_t</span> mask_new, mask_backup;</span><br><span class="line"><span class="type">int</span> stamp_backup = cstamp;</span><br><span class="line">syscall_set_time_stamp(<span class="number">0</span>, &amp;stamp_backup);</span><br><span class="line">mask_new.sig[<span class="number">0</span>] = syscall_get_sig_mask(<span class="number">0</span>, num, <span class="number">0</span>);</span><br><span class="line">mask_new.sig[<span class="number">1</span>] = syscall_get_sig_mask(<span class="number">0</span>, num, <span class="number">1</span>);</span><br><span class="line">mask_backup.sig[<span class="number">0</span>] = syscall_get_env_mask(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">mask_backup.sig[<span class="number">1</span>] = syscall_get_env_mask(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;mask_new, <span class="literal">NULL</span>);</span><br><span class="line">sa_handler(num);</span><br><span class="line">sigprocmask(SIG_SETMASK, &amp;mask_backup, <span class="literal">NULL</span>);</span><br><span class="line">syscall_set_time_stamp(<span class="number">0</span>, &amp;stamp_backup);</span><br><span class="line"><span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">user_panic(<span class="string">&quot;syscall_set_trapframe returned %d\n&quot;</span>, r);</span><br></pre></td></tr></table></figure>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/hany01rye">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%B8%B8%E9%87%8F%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">各种常量、函数和宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">Lab2 - 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="toc-number">2.1.</span> <span class="toc-text">内核程序启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">页管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Page%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">Page的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">管理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E4%B8%8A%E4%B8%80%E8%8A%82%E7%9A%84page-init"><span class="toc-number">2.2.3.</span> <span class="toc-text">回顾上一节的page_init</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EPage%E7%AE%A1%E7%90%86%E7%9A%84%E5%85%B6%E5%AE%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.4.</span> <span class="toc-text">关于Page管理的其它函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E7%9B%B8%E5%85%B3"><span class="toc-number">2.3.</span> <span class="toc-text">页表相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%86%E4%B8%8E%E8%BD%AC%E5%8C%96"><span class="toc-number">2.4.</span> <span class="toc-text">不同地址的区分与转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kseg0%E6%AE%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">kseg0段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kuseg%E6%AE%B5%EF%BC%88%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%89"><span class="toc-number">2.4.2.</span> <span class="toc-text">kuseg段（两级页表）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">2.5.</span> <span class="toc-text">TLB</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A7%E8%A1%A8%E9%A1%B9%E6%97%A0%E6%95%88%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">旧表项无效化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TLB%E9%87%8D%E5%A1%AB"><span class="toc-number">2.5.2.</span> <span class="toc-text">TLB重填</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">3.</span> <span class="toc-text">Lab3 - 进程与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97Env"><span class="toc-number">3.1.1.</span> <span class="toc-text">进程控制块Env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86ASID"><span class="toc-number">3.1.2.</span> <span class="toc-text">进程标识ASID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEEnv"><span class="toc-number">3.1.3.</span> <span class="toc-text">设置Env</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6%E5%B9%B6%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.4.</span> <span class="toc-text">加载文件并创建进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">3.1.5.</span> <span class="toc-text">进程的运行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">3.2.</span> <span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E5%8F%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">异常分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">3.2.2.</span> <span class="toc-text">时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%88%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">进程调度（时间片轮转）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E-fork"><span class="toc-number">4.</span> <span class="toc-text">Lab4 - 系统调用与 fork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">4.2.</span> <span class="toc-text">fork</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6COW"><span class="toc-number">4.2.1.</span> <span class="toc-text">写时复制COW</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">Lab5 - 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.</span> <span class="toc-text">磁盘空间布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.</span> <span class="toc-text">文件系统结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">5.3.</span> <span class="toc-text">块缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%94%A8%E6%88%B7%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.4.</span> <span class="toc-text">文件系统的用户接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lab6-%E7%AE%A1%E9%81%93%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A7%A3%E9%87%8A%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.</span> <span class="toc-text">Lab6 - 管道和命令解释程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E6%80%A7%E5%AE%9E%E9%AA%8C%EF%BC%88Lab4%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">挑战性实验（Lab4）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E8%87%B4%E6%80%9D%E8%B7%AF"><span class="toc-number">7.1.</span> <span class="toc-text">大致思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.1.</span> <span class="toc-text">如何传递信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.2.</span> <span class="toc-text">何时处理信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BF%A1%E5%8F%B7"><span class="toc-number">7.1.3.</span> <span class="toc-text">如何处理信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">7.1.4.</span> <span class="toc-text">其它需要注意的事情</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%BB%86%E8%8A%82"><span class="toc-number">7.2.</span> <span class="toc-text">具体实现及相关细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">7.2.1.</span> <span class="toc-text">信号集相关操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97Env%E9%9C%80%E8%A6%81%E5%A2%9E%E5%8A%A0%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">7.2.2.</span> <span class="toc-text">进程控制块Env需要增加的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-1"><span class="toc-number">7.2.3.</span> <span class="toc-text">系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.3.</span> <span class="toc-text">问题及解决方案</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://hany01rye.github.io/p/OS-Lab/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://hany01rye.github.io/p/OS-Lab/&text=OS实验汇总"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://hany01rye.github.io/p/OS-Lab/&is_video=false&description=OS实验汇总"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=OS实验汇总&body=Check out this article: https://hany01rye.github.io/p/OS-Lab/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://hany01rye.github.io/p/OS-Lab/&title=OS实验汇总"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://hany01rye.github.io/p/OS-Lab/&name=OS实验汇总&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick='$("#toc-footer").toggle();return false;'><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick='$("#share-footer").toggle();return false;'><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick='$("#nav-footer").toggle();return false;'><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 Rye Han
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/archives/">Archives</a></li>
         
          <li><a target="_blank" rel="noopener" href="http://github.com/hany01rye">Projects</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/lib/justified-gallery/justifiedGallery.min.css">



<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-86660611-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Disqus Comments -->


